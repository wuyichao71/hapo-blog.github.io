---
title: 计算机系统基础习题
date: 2023-01-28 22:13:09
mathjax: true
categories:
    - 计算机
tags:
    - 计算机系统基础
---
# 第一章
## 1.   
**中央处理器(CPU)**: 控制部件、运算部件和各类寄存器互连组成的电路(Central Processing Unit)。  
**算数逻辑部件(ALU)**: 用来进行算术逻辑运算的部件(Arithmetic Logic Unit)。  
**通用寄存器**: 用于临时存放从主存取来的数据或运算的结果。  
**程序计数器(PC)**: 用于CPU自动按序读取主存中的指令, 在执行当前指令过程中, 会自动计算出下一条指令地址并送到PC中保存。  
**指令寄存器**: 保存从主存中取出的指令的寄存器。  
**控制器**:  用于自动逐条取出指令并译码的部件。   
**主存储器**:  用来存放指令和数据。  
**总线**:  连接不同部件进行信息传输的介质。
<!--more-->  
**主存地址寄存器(MAR)**: CPU送到地址线的主存地址先存放在主存地址寄存器(MAR)。   
**主存数据寄存器(MDR)**: 发送到或从数据线取来的信息存放在主存数据寄存器(MDR)中。 
**指令操作码**: 指出指令的操作类型。 
**微操作**: 组成指令的若干个操作。  
**机器指令**: 计算机能理解和执行的由0和1组成的指令。  
**高级程序设计语言**: 面向算法设计的、较接近于日常英语书面语言的程序设计语言。  
**汇编语言**: 用简短的英文符号和机器指令建立对应关系，以方便程序员编写和阅读程序的机器语言的符号表示语言。  
**机器语言**: 使用特定计算机规定的指令格式而形成的0/1序列。   
**机器级语言**: 汇编语言和机器语言。  
**源程序**: 被翻译程序翻译的语言。  
**目标程序**: 翻译程序翻译生成的语言。  
**编译程序**: 实现将高级语言源程序翻译成汇编语言或机器语言目标程序的程序。  
**解释程序**: 实现将源程序中的语句按其执行顺序逐条翻译成机器指令并立即执行的程序。  
**汇编程序**: 实现将汇编语言源程序翻译成机器语言目标程序的程序。  
**语言处理系统**: 提供程序编辑器和各类翻译转换软件的工具包。  
**设备控制器**: I/O控制器或I/O控制器。  
**最终用户**: 使用应用软件完成特定任务的计算机用户。  
**系统管理员**: 利用操作系统、数据库管理系统等软件提供的功能对系统进行配置、管理和维护，以建立高效合理的系统环境供计算机用户使用的操作人员。  
**应用程序员**: 使用高级编程语言编制应用软件的程序员。  
**系统程序员**: 设计和开发系统软件的程序员。  
**指令集体系结构(ISA)**: 介于软件和硬件之间的接口。  
**微体系结构**:  ISA具体实现的组织。  
**透明**: 对实际存在的事物或概念感受不到。  
**响应时间**: 从作业提交开始到作业完成所用的时间。  
**吞吐率**: 在单位时间内所完成的工作量。  
**用户CPU时间**: 真正用于运行用户程序代码的时间。  
**系统CPU时间**: 执行用户程序而需要CPU运行操作系统程序的时间。  
**系统性能**: 系统的响应时间。  
**CPU性能**: 用户CPU时间。  
**时钟周期**: CPU的主脉冲信号的宽度。  
**主频**: CPU中的主脉冲信号的时钟频率。  
**CPI**: 一条指令所需的时钟周期数。  
**基准程序**: 专门用来进行性能评价的一组程序。  
**SPEC基准程序集**: 由Sun、MIPS、HP、Apollo、DEC五家公司提出的基准程序集。  
**SPEC比值**: 测试程序在Sun SPARCstation上运行的执行时间除以该程序在测试机器上的执行时间所得到的比值。  
**MIPS**: 平均每秒执行多少百万条指令。  
**峰值MIPS**: 选取一组指令组合，使得得到的平均CPI最次，由此得到的MIPS。  
**相对MIPS**: 根据某个公认的参考机型来定义的相应MIPS值。  
**MFLOPS(GFLOPS、TFLOPS、PFLOPS、EFLOPS)**: 每秒所执行的浮点运算由多少百万次。  

## 2.  
(1)冯·诺依曼计算机由运算器、控制器、存储器、输入设备、输出设备5个基本部件组成。控制器应能自动执行指令；运算器应能进行算术运算，也能进行逻辑运算；存储器不仅能存放数据，也能存放指令；操作人员可以通过输入/输出设备使用计算机。  
(2)**存储程序**方式的基本思想是: 必须将实现编好的程序和原始数据送入主存中后才能执行程序，以蛋程序被启动执行，计算机能在不需操作人员干预下自动完成逐条指令取出和执行任务。  
(3)一条指令的执行过程包含取指令，指令译码，PC增量，取操作数并执行，送结果这些过程。  
(4)计算机系统的层次结构按照应用(问题)，算法，编程(语言)，操作系统/虚拟机，指令集体系结构(ISA)，微体系结构，功能部件，电路，器件划分。  
(5)计算机系统的用户可以分为最终用户，系统管理员，应用程序员，系统程序员划分。最终用户工作在应用程序层，应用程序员工作在编译程序和汇编程序层次，系统管理员工作在操作系统层次，系统程序员工作在汇编程序和指令集体系结构层次。  
(6)程序的CPI和程序中各种指令的比例以及指令的CPI有关。  
(7)因为不同的机器的指令集不同，而且指令的功能也不同同样的指令条数所完成的功能可能完全不同，并且不同的机器的CPI和时钟周期也不同，同一条指令在不同机器上所用的时间不同。  

## 3.  
计算机将程序中的一条条指令读入主存中，通过控制器控制指令的读取，通过运算器进行运算，接着再执行下一条指令。  

## 4.  
熟悉的部分是操作系统，编译语言和应用程序，对计算机指令集体系结构，数字设计和电路设计不熟悉，想要更进一步了解计算机指令集体系结构。  

## 5.  
| 主存地址 | 主存单元内容 | 内容说明(Ii表示第i条指令) | 指令的符号表示 |
| ---- | ---- | ---- | ---- |
| 0 | 1110 1001 | I1: R[0] &larr; M[9] | load  r0, 9# |
| 1 | 0000 0100 | I2: R[1] &larr; R[0] | mov   r1, r0 |
| 2 | 1110 1000 | I3: R[0] &larr; M[8] | load  r0, 8# |
| 3 | 0010 0001 | I4: R[0] &larr; R[0]-R[1]; op=0010; 减操作| sub r0, r1|
| 4 | 0000 0100 | I5: R[1] &larr; R[0] | mov   r1, r0 |
| 5 | 1110 1001 | I6: R[0] &larr; M[9] | load  r0, 9# |
| 6 | 0011 0001 | I7: R[0] &larr; R[0]*R[1]; op=0011; 乘操作| mul r0, r1|
| 7 | 1111 1010 | I8: M[10] &larr; R[0] | store 10#, r0 |
| 8 | 0001 0000 | 操作数x, 值为16 | |
| 9 | 0010 0001 | 操作数y, 值为33 | |
| 10 | 0000 0000 | 结果z, 初始值为0 | |

| |I1:1110 1001|I2:0000 0100|I3:1110 1000|I4:0010 0001|I5:0000 0100|I6:1110 1001|I7:0011 0001|I8:1111 1010|
|----|----|----|----|----|----|----|----|----|
|取指令|IR&larr;M[0000]|IR&larr;M[0001]|IR&larr;M[0010]|IR&larr;M[0011]|IR&larr;M[0100]|IR&larr;M[0101]|IR&larr;M[0110]|IR&larr;M[0111]|
|指令译码|op=1110,取数|op=0000,传送|op=1110,取数|op=0010,减|op=0000,传送|op=1110,取数|op=0011,乘|op=1111,存数|
|PC增量|PC&larr;0000+1|PC&larr;0001+1|PC&larr;0010+1|PC&larr;0011+1|PC&larr;0100+1|PC&larr;0101+1|PC&larr;0110+1|PC&larr;0111+1|
|取数并执行|MDR&larr;M[1001]|A&larr;R[0],mov|MDR&larr;M[1000]|A&larr;R[0],B&larr;R[1],sub|A&larr;R[0],mov|MDR&larr;M[1001]|A&larr;R[0],B&larr;R[1],mul|MDR&larr;R[0]|
|送结果|R[0]&larr;MDR|R[1]&larr;F|R[0]&larr;MDR|R[0]&larr;F|R[1]&larr;F|R[0]&larr;MDR|R[0]&larr;F|M[1010]&larr;MDR|
|执行结果|R[0]=33|R[1]=33|R[0]=16|R[0]=16-33=-17|R[1]=-17|R[0]=33|R[0]=-561|M[10]=-561|

## 6.
(1)对于P1，M2更快，快2倍；对于P2，M1更快，快两倍。  
(2)在M1上执行P1和P2的速度分别是$\frac{200\times 10^6 I}{10 s} = 20$MIPS和$\frac{300\times 10^3 I}{3\times 10^{-3} s} = 100$MIPS。在M2上的执行速度分别为$\frac{150\times 10^{6} I}{5 s} = 30$MIPS和$\frac{420\times 10^3}{6\times10^{-3}} = 70$MIPS。对于P2, M1更快, 快$10/7$倍。  
(3)$$CPI = \frac{10\times800\times10^6}{200\times10^6} = 40$$  
$$CPI = \frac{5\times1200\times10^6}{150\times10^6} = 40$$  
在M1和M2上执行P1时的平均时钟周期(CPI)都是40。
(4)应该选择M2, 因为M2性价比更高。  
(5)应该选择M2， 因为P2程序的执行时间可以忽略不计。  

## 7.  
(1)M1的峰值MIPS为1000MIPS, M2的峰值MIPS为750MIPS。  
(2)M1更快，快19/18倍, 在M1和M2上执行程序P时的平均时钟周期数CPI各是12/5和19/5。  

## 8.
对于程序P来说, M2更快, 快4/3倍。  

## 9.
P在M上的执行时间为$\frac{8\times 10^9 \times 1.25}{4\times10^9} = 2.5$s。P占用的CPU时间的百分比是62.5%。  

## 10.
S1和S2各有10和8条。CPI分别为$\frac{1\times5+2\times2+3\times2+4\times1}{10} = 1.9$和$\frac{1\times1+2\times1+3\times1+4\times5}{8} = 3.25$。时钟周期数各为19和26。执行时间各为38ns和52ns。  

## 11.
$$原时钟周期 = 1.2\times10^9 \times 12$$
$$现时钟周期 = 1.2\times10^9 \times 10$$
因此被替换的指令条数为$\frac{原时钟周期-现时钟周期}{5-3} = 8\times10^8$  

## 12.
浮点数指令如何改进都不可能减半。访存指令的CPI要从4变成1。执行时间会变为原来的59/90。  

# 第二章
## 1.

**真值**: 机器数真正的值  
**机器数**: 数值数据在计算机内部编码表示后的数  
**数值数据**: 用来表示数量的多少, 可比较其大小, 分为整数和实数, 整数又分为无符号整数和带符号整数  
**非数值数据**: 没有大小之分的位串, 不表示数量的多少, 主要用来表示字符数据和逻辑数据  
**无符号整数**: 所有的二进位都用来表示数值而没有符号位  
**带符号整数**: 用一个二进位表示符号   
**定点数**: 小数点位置约定在固定位置  
**原码**: 由符号位直接跟数值位构成  
**补码**: 正数的补码符号为0, 数值部分是它本身; 负数的补码等于模于该负数绝对值之差  
**变形补码**: 采用双符号位的补码表示方法  
**溢出**: 当相加得到的和超出了n位数可表示的范围时, 剩下的低n位数不能正确表示运算  
**浮点数**: 小数点位置约定为可浮动的数  
**尾数**: 对于任意一个实数X, 可以表示为: $$X = (-1)^S\times M \times R^E$$  
M是一个二进制定点小数, 称为数X的尾数
**阶**: E是一个二进制定点小数, 称为数X的阶或指数  
**阶码**: 浮点数的阶都用一种称之为"移码"的编码方式。通常将阶的编码表示称为阶码  
**移码**: 为了简化比较操作, 对数加上一个正的常数 
**阶码下溢**: 阶数小于最小的阶  
**规格化数**: 真致的尾数部分中最高位具有非零数字  
**左规**: 尾数每左移一位, 阶码减1  
**右规**: 尾数每右移一位, 阶码加1  
**非规格化数**: 阶码为全0, 尾数最高位有一个或几个连续的0, 但不全为0  
**数字零**: 根据浮点数的表示格式, 只要尾数为0, 阶码取任何值其值都为0, 这样的数被称为机器数  
**非数(NaN)**: 没有定义的数   
**BCD码**:十进制数采用二进制编码, 通过专门的十进制数运算指令进行处理  
**逻辑数**: 将n位数据看成是由n个一位数据组成, 每个取值为0或1  
**ASCII码**: 美国标准信息交换码  
**汉字输入码**: 每个汉字用对应的按键进行的编码表示  
**汉字内码**: 汉字在计算机内部存储的编码方式  
**机器字长**: CPU内部用于整数运算的数据通路的宽度  
**大端方式**: 将数据的最高有效字节存放在小地址单元中  
**小端方式**: 将数据的最高有效字节存放在大地址单元中  
**最高有效位**: 用最高有效字字节(Most Significant Bit/MSB)表示最高位  
**最高有效字节(MSB)**: 以字节为一个排列基本单元表示时的最高位  
**最低有效位**: 用最低有效字字节(Least Significant Bit/MSB)表示最低位  
**最低有效字节(LSB)**: 以字节为一个排列基本单元表示时的最低位  
**掩码**: 通过于给定的一个位模式进行按位与, 可以提取所需要的位, 这里的位模式称为"掩码"  
**算数位移**: 左移时, 高位移出, 低位补0; 如果移出的高位不同于移位后的符号位, 也即, 若左移前、后符号位不同, 则发生"溢出", 右移时, 低位移出, 高位补符号  
**逻辑位移**: 左移时, 高位衣橱, 低位补0; 右移时, 低位移出, 高位补0  
**0扩展**: 在短的无符号数前面添加足够的0  
**符号扩展**: 在短的带符号整数前添加足够多的符号位  
**零标志ZF**: 表示结果为0, 当结果的所有位都为0时，ZF=1   
**溢出标志**: 表示带符号整数的加减运算发生溢出, 当X和Y‘的最高位相同且不同于结果的最高位时, OF=1  
**符号标志SF**: 表示带符号整数加减运算结果的符号位, 直接取结果的最高位作为SF  
**进位/借位标志**: 表示无符号数加减运算时的进/借位,加法时CF就应等于进位输出C; 减法时, 应将进位输出C取反来作为借位标志. 综合起来, 可得: $CF = Sub \oplus C$  

## 2.
