---
title: 计算机系统基础第七章习题
date: 2023-06-09 11:29:00
mathjax: true
categories:
    - 计算机
tags:
    - 计算机系统基础
---

# 第七章

## 1.
**CPU的控制流**: CPU所执行的指令的地址序列  
**正常控制流**: 通过按指令存放的顺序和跳转到由转移类指令指出的转移目标处执行得到的控制流  
**异常控制流**: 由于某些特殊情况引起用户程序的正常执行被打断所形成的意外控制流  
<!--more-->
**进程**: 一个具有一定独立功能的程序关于某个数据集合的一次运行活动  
**逻辑控制流**: 指令执行过程中形成的确定的指令执行地址序列  
**物理控制流**: 由多个进程的逻辑控制流轮流使用处理器组成的控制流   
**并发(concurrency)**: 不同进程的逻辑控制流在时间上交错或重叠的情况  
**并行(parallelism)**: 两个同时执行的进程的逻辑控制流  
**多任务**: 一段时间内会有多个不同的进程在系统中运行  
**时间片**: 连续执行同一个进程的时间段  
**进程的上下文**: 进程的物理实体(代码和数据等)和支持进程运行的环境合称为进程的上下文  
**系统级上下文**: 由进程标识信息、进程现场信息、进程控制信息和系统内核栈等组成的内核空间信息  
**用户级上下文**: 由用户进程的程序块、数据块、运行时的堆和用户栈(统称为用户堆栈)等组成的用户空间信息  
**寄存器上下文**: 处理器中各个寄存器的内容  
**进程控制信息**: 包含各种内核数据结构, 例如, 记录有关进程信息的进程表、页表、打开文件列表等  
**上下文切换**: 实现不同进程中指令交替执行的机制  
**内核空间**: 内核虚拟存储空间  
**用户空间**: 用户虚拟存储空间  
**内核控制路径**: 内核处理系统调用、异常和中断的指令序列  
**异常处理程序**: 处理异常事件的程序  
**中断服务程序**: 处理中断事件的程序  
**故障(fault)**: 引起故障的指令在执行过程中CPU检测到的一类于指令执行相关的意外事件  
**陷阱(trap)**: 是预先安排的一种"异常"事件  
**陷阱指令**: 当执行到陷阱指令时, CPU就调出特定的程序进行相应的处理, 处理结束后返回到陷阱指令的下一条指令执行  
**终止(abort)**: 终止发生问题的进程  
**中断请求信号**: 外部I/O设备通过特定的中断请求信号线向CPU提出中断请求  
**中断响应周期**: 在中断响应周期中, CPU现将当前PC值和当前的及其状态保存到栈中, 并设置"关中断"状态, 然后, 从数据总线读取中断类型号, 根据中断类型号跳转到对应的终端服务程序执行  
**中断类型号**: 决定对应的中断服务程序的类型号  
**开中断/关中断**: 中断允许位为1/0  
**可屏蔽中断**: 通过可屏蔽中断请求线INTR向CPU进行请求的中断  
**不可屏蔽中断**: 通过专门的不可屏蔽中断请求线NMI向CPU发出中断请求  
**断点**: 由外部I/O设备请求处理器进行的一种信号, 它不是由当前执行的指令引起的  
**程序状态字寄存器**: 一个存放状态信息的寄存器  
**程序状态字**: 存放在程序状态字寄存器中的信息  
**向量可断方式**: 硬件识别方式  
**中断向量**: 异常或中断处理程序的首地址  
**中断向量表**: 所有中断向量存放的一个表  
**异常/中断查询程序**: 操作系统中一个统一的异常或中断查询程序  
**中断描述符表**: 操作系统内核中的一个表, 记录了异常处理程序或中断服务程序的入口地址  
**I/O中断**: 由I/O外设发出的中断请求  
**时钟中断**: 由某个时钟产生的中断请求, 告知要给固定的时间间隔到  
**处理器中断**: 多处理器系统中其他处理器发出的中断请求  
**现场信息**: 在内核栈中保存各寄存器的内容  
**中断服务程序**: 执行中断响应过程的程序  
**中断服务例程**: 处理对应中断的例程  
**系统调用**: 是一种特殊的"异常事件", 是操作系统为用户程序提供服务的手段  
**系统调用号**: 用来确定系统调用跳转表中的偏移量  
**系统调用处理程序**: 是一个系统调用的统一入口  
**系统调用服务例程**: 执行系统调用处理程序后产生的例程  

## 2.
(1) 异常和中断
(2) 程序就是代码和数据的集合, 程序的代码是一个机器指令序列, 因而程序是一种静态的概念. 进程是程序的一次运行, 是一个具有一定独立功能的程序关于某个数据集合的一次运行活动, 因而进程具有动态的含义.
(3) 一个独立的逻辑控制流和一个私有的虚拟地址空间. 每个进程拥有一个独立的逻辑控制流, 使得程序员以为自己的程序在执行过程中独占使用处理器; 每个进程拥有一个私有的虚拟地址空间, 使得程序员以为自己的程序在执行过程中独占存储器.
(4) 异常控制流的机制: 进程与进程上下文切换, 异常的类型、异常的捕获和处理、中断的捕获和处理, 系统调用的实现机制等.
(5) 1.将当前处理器的寄存器上下文保存到当前进程的系统级上下文的现场信息中; 2.将新进程系统级上下文中的现场信息作为新的寄存器上下文恢复到处理器的各个寄存器中; 3.将控制转移到新进程执行.
(6) 进程用户空间有4个区域(私有的只读代码区和已初始化数据区、共享的代码区和数据区)被映射到普通文件中的对象: 只读代码区域(.text)和已初始化数据区域(.data)与可执行文件中私有的写时拷贝对象进行映射; 共享库的数据区域和代码区域与共享库文件中的共享对象分别进行映射. 除了上述区域外, 未初始化数据(.bss)、栈和堆这三个区域都是私有的、请求零的页面. 映射到匿名文件.
(7) 保护断点和程序状态、关中断、识别异常和中断时间并转到相应处理程序执行.
(8) 陷阱机制
(9) 断点和程序状态
(10) 各寄存器的内容
(11) 从C语言编程者角度来看, 系统级函数在形式上与普通的应用编程接口(API)以及普通的C语言函数没有差别. 但是, 实际上它们在机器级代码的具体实现上是不同的. 例如, 在IA-32+Linux中, 普通函数(包括API)使用CALL指令来实现过程调用, 而系统调用则使用陷阱指令(如int $0x80或sysenter)来实现. 对于过程调用, 执行CALL指令前后, 处理器一直在用户态下执行指令, 因此, 所执行的指令是受限的, 所能访问的存储空间也是受限的; 而对于系统调用, 一旦执行了发出系统调用的陷阱指令, 处理器就从用户态转到内核态下运行, 此时, CPU可以执行特权指令并访问内核空间.
(12) 中断向量表: 高16位是段地址, 低16位是偏移地址; 中断描述符表: 类型(向量)号、助记符、含义、事件源.

## 3.
全都是

## 4.
(1) 可能
(2) 
第1条指令: 可能会发生页故障, 是可恢复的, 因为代码运行在0x8048000, 而访问的数据处于0x80497d0, 不处于同一页, 因此可能发生缺页, 图为7.10.  
第2条指令: 可能会发生页故障, 是可恢复的, 因为k处于0x804a324, 处于一个新的页, 可能发生缺页.  
第6条指令: 不会发生缺页.  
第7条指令: 可能发生页故障, 可能无法恢复, 因为可能会跨越到别的区域中, 图为7.13.  
(3) 会发生除0故障, 不能恢复.

## 5.
(1) 用户态, 因为还未触发陷阱指令, 内核态
(2) 是, 系统门, 128, P=1; DPL=3: TYPE=1111B, 基地址=0H: 限界=FFFFH; G=1; S=1; TYPE=10; DPL=0; D=1; P=1 
(3) 执行IDT0, 细节略, 异常处理完成后转入abort例程终止故障的进程.

## 6.
IA-32: 检测异常和中断, 确定异常/中断类型. 
Linux: 保存各寄存器的内容, 用C函数进行具体的异常处理, 恢复各个寄存器.
