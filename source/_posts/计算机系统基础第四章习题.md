---
title: 计算机系统基础第四章习题
date: 2023-05-11 01:54:16
mathjax: true
categories:
    - 计算机
tags:
    - 计算机系统基础
---
# 第四章

## 1.
**链接**: 将一个程序的所有关联模块对应的目标代码文件结合在一起, 以形成一个可执行文件的过程  
**可重定位目标文件**: 对每个模块进行预处理、编译、汇编生成的二进制代码  
**可执行目标文件**: 将若干可重定位目标文件(可能包括若干标准库函数目标模块)组合起来的二进制文件  
**符号解析**: 将每个符号的引用与一个确定的符号定义建立关联  
**重定位**: 重新确定代码和数据的地址并更新指令中被引用符号地址的工作
**ELF目标文件格式**: 可执行可链接格式  
**ELF头**: ELF头位于目标文件的起始位置, 包含文件结构说明信息   
**节头表**: 节头表由若干个表项组成, 每个表项描述相应的一个节的节名、在文件中的偏移、大小、访问属性、对齐方式等, 目标文件中的每个节都有一个表项与之对应  
**程序头表(段头表)**: 程序头表用于描述可执行文件中的代和属于与存储空间的映射, 一个表项对应一个连续的存储段或特殊节  
**只读代码段**: 只读不可写  
**可读写数据段**: 可读写
**全局符号**: 包括非静态的函数名和被定义为不带static属性的全局变量名  
**外部符号**: 在其他模块定义的外部函数名和外部变量名  
**本地符号**: 带static属性的函数名和全局变量名  
**强符号**: 函数名和已初始化的全局变量名是强符号  
**弱符号**: 未初始化的全局变量名是弱符号  
**多重定义符号**: 多次被定义的符号  
**静态库**: 将多个目标模块打包成一个单独的库文件  
**符号的定义**: 程序中的符号包括全局静态变量名和函数名, 他们在程序中可能出现在定义处  
**符号的引用**: 出现在引用处  
**未解析符号**: 还未与对应定义符号关联的引用符号  
**重定位信息**: 在可重定位目标文件的`.rel.text`节和`.rel.data`节中, 存放着每个需重定位的符号的重定位信息
**运行时堆**: 可读写数据段后面4KB对齐的高地址处, 通过调用malloc库函数动态向高地址分配空间  
**用户栈**: 从用户空间的最大地址往低地址方向增长  
**动态链接**: 在可执行目标文件装入或运行时被动态地装入内存并自动被链接  
**共享库(目标)文件**: 其中记录了相应的代码、数据、重定位和符号表信息
**位置无关代码(PIC)**: 共享库代码的加载位置可以是不确定的, 而且共享库代码的长度发生变化也不影响调用它的程序  
**全局偏移量表(GOT)**: 设置在数据段起始处的用于存放全局变量地址的表  
**延迟绑定**: 对于模块间过程的引用不在加载时进行重定位, 而是延迟到第一次函数调用时进行重定位  
**过程链接表(PLT)**: PLT是.text节的一部分, 每个表项中实际上包含的是3条代码, 占16字节  

## 2.
(1) 链接可以将C语言源程序模块组合起来生成一个可执行目标文件. 从源程序到可执行及其代码的转换过程需要预处理、编译、汇编和链接. 
(2) 使用链接的第一个好处就是"模块化", 它能使一个程序被划分成多个模块, 由不同的程序员进行编写, 并且可以构建公共的函数库以提供给不同的程序进行重用. 采用链接的第二个好处是"效率高", 每个模块可以分开编译, 在程序修改时只需重新编译那些修改过的源程序文件, 然后再重新链接, 因而从时间上来说能够提高程序开发的效率; 同时, 因为源程序文件中无须包含共享库的所有代码, 只要直接调用即可, 而且在可执行文件运行时的内存中, 也只需要包含所调用函数的代码而不需要包含整个共享库, 所以链接也有效地提高了空间利用率.
(3)
与ELF可重定位目标文件格式相比, ELF可执行目标文件的不同点主要有: 
1. ELF头中的字段`e_entry`给出了系统将控制权转移到的起始虚拟地址(入口点), 即执行程序时第一条指令的地址. 而在可重定位文件中, 此字段为0.
2. 通常情况下, 会带有一个`.init`节和一个`.fini`节, 其中`.init`节定义了一个`_init`函数, 用于可执行目标文件开始执行时的初始化工作, 当程序开始运行时, 系统会在进程进入主函数之前, 现执行这个节中的指令代码. `_fini`节中包含进程终止时要执行的指令代码, 当程序退出时, 系统会执行这个节中的指令代码.
3. 少了`.rel.text`和`.rel.data`等重定位信息节. 因为可执行目标文件中的指令和数据已被重定位, 故可去掉用于重定位的节.
4. 多了一个程序头表, 也称段头表, 他是一个结构数组. 
   
(4) 符号解析和重定位
(5) 
.text: 目标代码部分
.rodata: 只读数据, 如printf语句中的格式串、开关语句(如switch-case)的跳转表等
.data: 已初始化的全局变量
.bss: 未初始化的全局变量
(6) 同上
(7) 可执行目标文件中有只读代码段和可读写数据段是可装入段. ELF头、程序头表、.init节、.fini节、.text节、.rodata节构成了只读代码段. .data节和.bss节构成了可读写数据段. 
(8) 程序头表
(9) 
1. 引入统一的虚拟地址空间简化了链接器的设计和实现.
2. 引入虚拟地址空间也简化了程序加载过程.

(10) 共享库的动态链接有两个方面的特点: 一是"共享性", 二是"动态性".

## 3.
|符号|是否在`test.o`的符号表中|定义模块|符号类型|节|
|-|-|-|-|-|
|a|是|`main.o`|外部|`UND`|
|val|是|`test.o`|全局|`.bss`|
|sum|是|`test.o`|全局|`.text`|
|i|否||||
> 在linux32下`val = 0`则被分配在`.bss`中, 否则被分配在`.data`中.

## 4.
|符号|是否在`swap.o`的符号表中|定义模块|符号类型|节|
|-|-|-|-|-|
|buf|是|`main.o`|外部|`UND`|
|bufp0|是|`swap.o`|全局|`.data`|
|bufp1|是|`swap.o`|本地|`.bss`|
|incr|是|`swap.o`|本地|`.text`|
|count|是|`swap.o`|本地|`.bss`|
|swap|是|`swap.o`|全局|`.text`|
|temp|否||||
> 经过变成发现`bufp0`的节是`.data.rel`

## 5.
(1) 在`main.c`中, x, z, main为强符号, y, proc1是弱符号; 在`proc1.c`中, proc1为强符号, x为弱符号.
(2) `x=0, z=0`
proc1()函数调c用前
|地址|内容|
|-|-|
|&x|257|
|&z|2|
proc()函数调用后
|地址|内容|
|-|-|
|&x|0|
|&z|0|
`x=0, z=-16392`
(3)
```C
/* 1 */
unsigned x;

void proc1()
{
    x = 257;
}

/* 2 */
double x;

void proc1()
{
    x = 1.0000019073486899;
}
```
## 6.
(1)
1. REF(m1.main)&rarr;DEF(m1.main)
2. REF(m2.main)&rarr;DEF(m2.main)
3. 链接错误, p1不是函数指针
4. REF(m2.p1)&rarr;DEF(m2.p1)

(2)
1. 链接错误, `m1.c`和`m2.c`中的main都为强定义
2. 链接错误, `m1.c`和`m2.c`中的main都为强定义
3. 链接错误, `m1.c`和`m2.c`中的x都为强定义

(3)
1. RFF(m1.main)&rarr;DEF(m1.main)
2. REF(m2.main)&rarr;DEF(m1.main)
3. 链接错误, 在`m1.c`中重复定义p1
4. 不存在关联
5. REF(m2.x)&rarr;DEF(m2.x)

(4)
1. REF(m1.x)&rarr;DEF(m2.x)
2. REF(m2.x)&rarr;DEF(m2.x)
3. REF(m1.y)&rarr;DEF(m1.y);DEF(m2.y)
4. RED(m2.y)&rarr;DEF(m1.y);DEF(m2.y)

## 7.
`m2.c`中的`main`为弱类型, 因此它指向了`m1.c`中的main函数.

## 8.
其中的28字节用于储存未初始化的局部变量的`.bss`节

## 9.
`gcc -static -o p p.o libx.a liby.a`
`gcc -static -o p p.o liby.a libx.a liby.a`
`gcc -static -o p p.o libx.a liby.a libx.a libz.a`

## 10.
符号名:`swap`
相对于`.text`节起始位置的位移: `0x7`
所在指令行号: `6`
重定位类型: `R_386_PC32`重定位类型
重定位前内容: `0xfffffffc`, `-4`
重定位后内容: `0x00000009`, `9`
计算过程: `0x8048384 - (0x8048386 + 0x7 - (-4))`

## 11.
|序号|符号|位移|指令所在行号|重定位类型|重定位前内容|重定位后内容|
|-|-|-|-|-|-|-|
|1|bufp1(.bss)|0x8|6~7|R_386_32|0x00000000|0x8049620|
|2|buf|0xc|6~7|R_386_32|0x00000000|0x80495cc|
|3|bufp0|0x11|10|R_386_32|0x00000000|0x80495d0|
|4|bufp0|0x1b|14|R_386_32|0x00000000|0x80495d0|
|5|bufp1|0x21|16|R_386_32|0x00000000|0x8049620|
|6|bufp1|0x2a|29|R_386_32|0x00000000|0x8049620|
